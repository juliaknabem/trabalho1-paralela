#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "randomlist.h"
#include <pthread.h>

struct bucket {
    int n_elem;
    int index; // [start : n_elem)
    int start; //starting point in B array
};

int cmpfunc(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

struct ThreadData {
    int id;
    int num_threads;
    int *A;
    int *B;
    struct bucket *buckets;
    int *global_n_elem;
    int *global_starting_position;
    int dim;
};

void *parallelBucketSort(void *arg) {
    struct ThreadData *data = (struct ThreadData *)arg;

    int num_threads = data->num_threads;
    int dim = data->dim;
    int my_id = data->id;
    int *A = data->A;
    int *B = data->B;
    struct bucket *buckets = data->buckets;
    int *global_n_elem = data->global_n_elem;
    int *global_starting_position = data->global_starting_position;
    int limit = 1000000;
    int w = limit / n_buckets;

    int j, k, b_index;
    int local_index; // [0 : n_buckets)
    int real_bucket_index; // [0 : n_buckets * num_threads)
    int workload = dim / num_threads;
    int previous_index;

    for (int i = 0; i < dim; i++) {
        local_index = A[i] / w;
        if (local_index > n_buckets - 1)
            local_index = n_buckets - 1;
        real_bucket_index = local_index + my_id * n_buckets;
        buckets[real_bucket_index].n_elem++;
    }

    int local_sum = 0;
    for (j = my_id; j < n_buckets * num_threads; j = j + num_threads) {
        local_sum += buckets[j].n_elem;
    }
    global_n_elem[my_id] = local_sum;

    for (j = 1; j < n_buckets; j++) {
        global_starting_position[j] = global_starting_position[j - 1] + global_n_elem[j - 1];
        buckets[j].start = buckets[j - 1].start + global_n_elem[j - 1];
        buckets[j].index = buckets[j - 1].index + global_n_elem[j - 1];
    }

    for (j = my_id + n_buckets; j < n_buckets * num_threads; j = j + num_threads) {
        int previous_index = j - n_buckets;
        buckets[j].start = buckets[previous_index].start + buckets[previous_index].n_elem;
        buckets[j].index = buckets[previous_index].index + buckets[previous_index].n_elem;
    }

    for (int i = 0; i < dim; i++) {
        j = A[i] / w;
        if (j > n_buckets - 1)
            j = n_buckets - 1;
        k = j + my_id * n_buckets;
        b_index = buckets[k].index++;
        B[b_index] = A[i];
    }

    for (int i = 0; i < n_buckets; i++)
        qsort(B + global_starting_position[i], global_n_elem[i], sizeof(int), cmpfunc);

    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    int *B, *temp;
    int n_buckets, i, w, limit, num_threads, workload, b_index;
    struct bucket *buckets; //array of buckets
    double t1; // Timing variable
    float total; //total time

    // global buckets
    n_buckets = 20;
    int global_n_elem[n_buckets]; //number of elements in each bucket
    int global_starting_position[n_buckets]; //starting position in A for each bucket
    memset(global_n_elem, 0, sizeof(int) * n_buckets);
    memset(global_starting_position, 0, sizeof(int) * n_buckets);

    initializeRandomList(6000000);
    num_threads = n_buckets;

    pthread_t threads[num_threads];
    struct ThreadData threadData[num_threads];

    limit = 1000000;
    w = limit / n_buckets;
    B = (int *)malloc(sizeof(int) * dim);

    for (i = 0; i < num_threads; i++) {
        threadData[i].id = i;
        threadData[i].num_threads = num_threads;
        threadData[i].A = A;
        threadData[i].B = B;
        threadData[i].buckets = buckets;
        threadData[i].global_n_elem = global_n_elem;
        threadData[i].global_starting_position = global_starting_position;
        threadData[i].dim = dim;

        pthread_create(&threads[i], NULL, parallelBucketSort, &threadData[i]);
    }

    for (i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    total = omp_get_wtime() - t1;
    tmp = A;
    A = B;
    B = tmp;

    if (dim <= 40) {
        printf("A \n");
        for (i = 0; i < dim; i++) {
            printf("%d ", A[i]);
        }
        printf("\n");
    }
    printf("Sorting %d elements took %f seconds\n", dim, total);

    int sorted = 1;
    for (i = 0; i < dim - 1; i++) {
        if (A[i] > A[i + 1])
            sorted = 0;
    }
    if (!sorted)
        printf("The data is not sorted!!!\n");

    free(B);
}
